<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 - byä½œè€…gwjh (å¸¦å­˜æ¡£)</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #faf8ef;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 50px 10px 20px 10px; 
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .author {
            font-size: 16px;
            color: #776e65;
            margin-top: 0;
            margin-bottom: 5px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        h1 {
            font-size: 40px;
            color: #776e65;
            margin: 0; /* ä¿®æ”¹ margin ä»¥ä¾¿å¸ƒå±€ */
            line-height: 1;
        }

        .header-container, .controls, .game-container {
            width: 90vw;
            max-width: 400px;
        }

        .header-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            align-items: center;
        }

        /* æ–°å¢ï¼šç”¨äºåŒ…è£¹ä¸¤ä¸ªåˆ†æ•°æ¡†çš„å®¹å™¨ */
        .scores-wrapper {
            display: flex;
            gap: 5px;
        }

        .score-container {
            background-color: #bbada0;
            padding: 5px 10px; /* ç¨å¾®å‡å°å†…è¾¹è·ä»¥å®¹çº³ä¸¤ä¸ªæ¡† */
            border-radius: 5px;
            color: white;
            text-align: center;
            min-width: 55px;
        }

        .score-label { font-size: 11px; color: #eee4da; margin-bottom: 2px; }
        .score-value { font-size: 18px; font-weight: bold; }

        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 5px;
        }

        button {
            background-color: #8f7a66;
            color: white;
            border: none;
            padding: 12px 0;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            flex: 1; 
            transition: background-color 0.2s;
        }

        button:hover { background-color: #7f6a56; }

        button.active {
            background-color: #e74c3c;
            box-shadow: 0 0 8px #c0392b;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .game-container {
            background-color: #bbada0;
            border-radius: 10px;
            position: relative;
            padding: 10px;
            box-sizing: border-box;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            aspect-ratio: 1 / 1; 
        }

        .tile-cell {
            background-color: #cdc1b4;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            font-weight: bold;
            color: #776e65;
            transition: all 0.1s ease-in-out;
        }

        .remove-mode-active .tile-cell:not(:empty) {
            cursor: crosshair;
            animation: shake 0.5s;
        }
        
        .remove-mode-active .tile-cell[data-val="0"] {
            animation: none;
            cursor: default;
        }

        @keyframes shake {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(2deg); }
            75% { transform: rotate(-2deg); }
            100% { transform: rotate(0deg); }
        }

        @media (max-width: 350px) {
            .tile-cell { font-size: 20px; }
        }

        .tile-2 { background-color: #eee4da; }
        .tile-4 { background-color: #ede0c8; }
        .tile-8 { background-color: #f2b179; color: #f9f6f2; }
        .tile-16 { background-color: #f59563; color: #f9f6f2; }
        .tile-32 { background-color: #f67c5f; color: #f9f6f2; }
        .tile-64 { background-color: #f65e3b; color: #f9f6f2; }
        .tile-128 { background-color: #edcf72; color: #f9f6f2; font-size: 24px; }
        .tile-256 { background-color: #edcc61; color: #f9f6f2; font-size: 24px; }
        .tile-512 { background-color: #edc850; color: #f9f6f2; font-size: 24px; }
        .tile-1024 { background-color: #edc53f; color: #f9f6f2; font-size: 18px; }
        .tile-2048 { background-color: #edc22e; color: #f9f6f2; font-size: 18px; }

        .msg {
            width: 90vw;
            max-width: 400px;
            margin-top: 15px;
            color: #776e65;
            font-size: 13px;
            text-align: center;
            line-height: 1.6;
        }
    </style>
</head>
<body>

    <div class="author">byä½œè€…gwjh</div>

    <div class="header-container">
        <h1>2048</h1>
        
        <div class="scores-wrapper">
            <div class="score-container">
                <div class="score-label">åˆ†æ•°</div>
                <div class="score-value" id="score">0</div>
            </div>
            <!-- æ–°å¢æœ€é«˜åˆ†æ˜¾ç¤º -->
            <div class="score-container">
                <div class="score-label">æœ€é«˜åˆ†</div>
                <div class="score-value" id="best-score">0</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button onclick="game.restart()">ğŸ”„ é‡æ¥</button>
        <button onclick="game.undo()">â†© æ‚”æ£‹</button>
        <button id="removeBtn" onclick="game.toggleRemoveMode()">ğŸ”¨ æ¶ˆé™¤</button>
    </div>

    <div class="game-container" id="grid-container">
        <!-- ç½‘æ ¼ç”ŸæˆåŒº -->
    </div>

    <div class="msg">
        ç”µè„‘ï¼šæ–¹å‘é”®ç§»åŠ¨ | æ‰‹æœºï¼šæ‰‹æŒ‡æ»‘åŠ¨<br>
        <strong>è‡ªåŠ¨å­˜æ¡£ï¼š</strong>åˆ·æ–°é¡µé¢ä¸ä¸¢å¤±è¿›åº¦ã€‚<br>
        <strong>æ¶ˆé™¤æ¨¡å¼ï¼š</strong>ç‚¹å‡»å¼€å¯åï¼Œç‚¹è°è°æ¶ˆå¤±ã€‚
    </div>

<script>
    class Game2048 {
        constructor() {
            this.size = 4;
            this.grid = [];
            this.score = 0;
            this.bestScore = 0; // æ–°å¢æœ€é«˜åˆ†å˜é‡
            this.history = []; 
            this.isRemoveMode = false; 

            // å®šä¹‰ LocalStorage çš„é”®åï¼Œé˜²æ­¢å†²çª
            this.storageKeys = {
                grid: 'gwjh_2048_grid',
                score: 'gwjh_2048_score',
                bestScore: 'gwjh_2048_bestScore',
                history: 'gwjh_2048_history'
            };

            this.gridContainer = document.getElementById('grid-container');
            this.scoreDisplay = document.getElementById('score');
            this.bestScoreDisplay = document.getElementById('best-score'); // è·å–æœ€é«˜åˆ†å…ƒç´ 
            this.removeBtn = document.getElementById('removeBtn');

            this.touchStartX = 0;
            this.touchStartY = 0;
            this.touchEndX = 0;
            this.touchEndY = 0;

            // å°è¯•åŠ è½½å­˜æ¡£ï¼Œå¦‚æœæ²¡æœ‰å­˜æ¡£åˆ™åˆå§‹åŒ–æ–°æ¸¸æˆ
            this.loadGame(); 
            this.setupInput();
        }

        // ä» LocalStorage åŠ è½½æ•°æ®
        loadGame() {
            const savedGrid = localStorage.getItem(this.storageKeys.grid);
            const savedScore = localStorage.getItem(this.storageKeys.score);
            const savedBest = localStorage.getItem(this.storageKeys.bestScore);
            const savedHistory = localStorage.getItem(this.storageKeys.history);

            // åŠ è½½æœ€é«˜åˆ†ï¼ˆå¦‚æœæœ‰ï¼‰
            this.bestScore = savedBest ? parseInt(savedBest) : 0;

            // æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„æ¸¸æˆå­˜æ¡£
            if (savedGrid) {
                this.grid = JSON.parse(savedGrid);
                this.score = parseInt(savedScore) || 0;
                this.history = savedHistory ? JSON.parse(savedHistory) : [];
                this.isRemoveMode = false;
                this.updateRemoveBtnStyle();
                this.draw();
            } else {
                // æ²¡æœ‰å­˜æ¡£ï¼Œå¼€å§‹æ–°æ¸¸æˆ
                this.init();
            }
        }

        // ä¿å­˜æ•°æ®åˆ° LocalStorage
        saveData() {
            localStorage.setItem(this.storageKeys.grid, JSON.stringify(this.grid));
            localStorage.setItem(this.storageKeys.score, this.score);
            localStorage.setItem(this.storageKeys.bestScore, this.bestScore);
            localStorage.setItem(this.storageKeys.history, JSON.stringify(this.history));
        }

        // æ¸…é™¤å½“å‰æ¸¸æˆè¿›åº¦ï¼Œä½†ä¿ç•™æœ€é«˜åˆ†
        clearCurrentGameData() {
            localStorage.removeItem(this.storageKeys.grid);
            localStorage.removeItem(this.storageKeys.score);
            localStorage.removeItem(this.storageKeys.history);
            // æ³¨æ„ï¼šä¸æ¸…é™¤ bestScore
        }

        init() {
            this.grid = Array(this.size).fill().map(() => Array(this.size).fill(0));
            this.score = 0;
            this.history = [];
            this.isRemoveMode = false;
            this.updateRemoveBtnStyle();
            
            this.addNewTile();
            this.addNewTile();
            this.draw();
            this.saveData(); // åˆå§‹åŒ–åç«‹å³ä¿å­˜çŠ¶æ€
        }

        restart() {
            if(confirm("ç¡®å®šé‡æ–°å¼€å§‹å—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ã€‚")) {
                this.clearCurrentGameData(); // æ¸…é™¤æ—§è¿›åº¦
                this.init(); // é‡æ–°åˆå§‹åŒ–
            }
        }

        saveState() {
            const gridCopy = this.grid.map(row => [...row]);
            this.history.push({
                grid: gridCopy,
                score: this.score
            });
            // è¿™é‡Œä¸éœ€è¦è°ƒç”¨ saveDataï¼Œå› ä¸º saveState é€šå¸¸æ˜¯åœ¨ç§»åŠ¨å‰è°ƒç”¨ï¼Œ
            // è€ŒçœŸæ­£çš„æŒä¹…åŒ–å­˜å‚¨åœ¨ç§»åŠ¨å®Œæˆåè¿›è¡Œ
        }

        undo() {
            if (this.history.length > 0) {
                const lastState = this.history.pop();
                this.grid = lastState.grid;
                this.score = lastState.score;
                this.draw();
                this.saveData(); // æ‚”æ£‹åä¿å­˜çŠ¶æ€
            }
        }

        toggleRemoveMode() {
            this.isRemoveMode = !this.isRemoveMode;
            this.updateRemoveBtnStyle();
            this.draw();
        }

        updateRemoveBtnStyle() {
            if (this.isRemoveMode) {
                this.removeBtn.classList.add('active');
                this.removeBtn.innerText = "é€€å‡ºæ¶ˆé™¤æ¨¡å¼"; 
                this.gridContainer.classList.add('remove-mode-active');
            } else {
                this.removeBtn.classList.remove('active');
                this.removeBtn.innerText = "ğŸ”¨ æ¶ˆé™¤";
                this.gridContainer.classList.remove('remove-mode-active');
            }
        }

        addNewTile() {
            let emptyCells = [];
            for (let r = 0; r < this.size; r++) {
                for (let c = 0; c < this.size; c++) {
                    if (this.grid[r][c] === 0) {
                        emptyCells.push({r, c});
                    }
                }
            }

            if (emptyCells.length > 0) {
                let randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                this.grid[randomCell.r][randomCell.c] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        draw() {
            this.gridContainer.innerHTML = '';
            
            // æ›´æ–°å½“å‰åˆ†æ•°
            this.scoreDisplay.innerText = this.score;
            
            // æ›´æ–°æœ€é«˜åˆ†é€»è¾‘
            if (this.score > this.bestScore) {
                this.bestScore = this.score;
            }
            this.bestScoreDisplay.innerText = this.bestScore;

            for (let r = 0; r < this.size; r++) {
                for (let c = 0; c < this.size; c++) {
                    let val = this.grid[r][c];
                    let cell = document.createElement('div');
                    cell.classList.add('tile-cell');
                    
                    cell.setAttribute('data-val', val);

                    if (val > 0) {
                        cell.classList.add(`tile-${val <= 2048 ? val : 2048}`);
                        cell.innerText = val;
                    }

                    cell.onclick = () => {
                        if (this.isRemoveMode) {
                            this.removeTile(r, c);
                        }
                    };

                    this.gridContainer.appendChild(cell);
                }
            }
        }

        removeTile(r, c) {
            if (this.grid[r][c] !== 0) {
                this.saveState();
                this.grid[r][c] = 0;
                this.draw();
                this.saveData(); // æ¶ˆé™¤åä¿å­˜
            }
        }

        setupInput() {
            document.addEventListener('keydown', (e) => {
                if (this.isRemoveMode) return; 
                let moved = false;
                switch(e.key) {
                    case 'ArrowUp': moved = this.moveUp(); break;
                    case 'ArrowDown': moved = this.moveDown(); break;
                    case 'ArrowLeft': moved = this.moveLeft(); break;
                    case 'ArrowRight': moved = this.moveRight(); break;
                }
                if (moved) this.afterMove();
            });

            this.gridContainer.addEventListener('touchstart', (e) => {
                if (this.isRemoveMode || e.touches.length > 1) return;
                this.touchStartX = e.touches[0].clientX;
                this.touchStartY = e.touches[0].clientY;
                e.preventDefault(); 
            }, { passive: false });

            this.gridContainer.addEventListener('touchend', (e) => {
                if (this.isRemoveMode) return;
                this.touchEndX = e.changedTouches[0].clientX;
                this.touchEndY = e.changedTouches[0].clientY;
                this.handleSwipe();
            }, { passive: false });
        }

        handleSwipe() {
            let dx = this.touchEndX - this.touchStartX;
            let dy = this.touchEndY - this.touchStartY;
            let absDx = Math.abs(dx);
            let absDy = Math.abs(dy);

            if (Math.max(absDx, absDy) < 30) return;

            let moved = false;
            if (absDx > absDy) {
                if (dx > 0) moved = this.moveRight();
                else moved = this.moveLeft();
            } else {
                if (dy > 0) moved = this.moveDown();
                else moved = this.moveUp();
            }

            if (moved) this.afterMove();
        }

        afterMove() {
            this.addNewTile();
            this.draw();
            this.saveData(); // ç§»åŠ¨å¹¶ç”Ÿæˆæ–°å—åï¼Œä¿å­˜æ‰€æœ‰æ•°æ®

            if (this.checkGameOver()) {
                // å»¶è¿Ÿä¸€ç‚¹å¼¹çª—ï¼Œè®©ç©å®¶çœ‹åˆ°æœ€åä¸€æ­¥
                setTimeout(() => {
                    alert("æ¸¸æˆç»“æŸï¼è¯·æ‚”æ£‹æˆ–ä½¿ç”¨æ¶ˆé™¤åŠŸèƒ½ã€‚");
                    // æ¸¸æˆç»“æŸä¹Ÿå¯ä»¥é€‰æ‹©æ¸…é™¤è¿›åº¦ï¼Œæˆ–è€…ä¿ç•™è®©ç©å®¶æ‚”æ£‹
                    // è¿™é‡Œæˆ‘ä»¬ä¿ç•™è¿›åº¦ï¼Œå…è®¸ç©å®¶æ‚”æ£‹
                }, 300);
            }
        }

        slideRow(row) {
            let arr = row.filter(val => val !== 0);
            for (let i = 0; i < arr.length - 1; i++) {
                if (arr[i] === arr[i+1]) {
                    arr[i] *= 2;
                    this.score += arr[i];
                    arr[i+1] = 0;
                }
            }
            arr = arr.filter(val => val !== 0);
            while (arr.length < this.size) arr.push(0);
            return arr;
        }

        moveLeft() {
            this.saveState();
            let moved = false;
            for (let r = 0; r < this.size; r++) {
                let oldRow = this.grid[r];
                let newRow = this.slideRow(oldRow);
                this.grid[r] = newRow;
                if (oldRow.join(',') !== newRow.join(',')) moved = true;
            }
            if (!moved) this.history.pop();
            return moved;
        }

        moveRight() {
            this.saveState();
            let moved = false;
            for (let r = 0; r < this.size; r++) {
                let oldRow = this.grid[r];
                let reversedRow = [...oldRow].reverse();
                let newRow = this.slideRow(reversedRow).reverse();
                this.grid[r] = newRow;
                if (oldRow.join(',') !== newRow.join(',')) moved = true;
            }
            if (!moved) this.history.pop();
            return moved;
        }

        moveUp() {
            this.saveState();
            let moved = false;
            for (let c = 0; c < this.size; c++) {
                let col = [];
                for (let r = 0; r < this.size; r++) col.push(this.grid[r][c]);
                let newCol = this.slideRow(col);
                for (let r = 0; r < this.size; r++) {
                    if (this.grid[r][c] !== newCol[r]) moved = true;
                    this.grid[r][c] = newCol[r];
                }
            }
            if (!moved) this.history.pop();
            return moved;
        }

        moveDown() {
            this.saveState();
            let moved = false;
            for (let c = 0; c < this.size; c++) {
                let col = [];
                for (let r = 0; r < this.size; r++) col.push(this.grid[r][c]);
                let reversedCol = col.reverse();
                let newCol = this.slideRow(reversedCol).reverse();
                for (let r = 0; r < this.size; r++) {
                    if (this.grid[r][c] !== newCol[r]) moved = true;
                    this.grid[r][c] = newCol[r];
                }
            }
            if (!moved) this.history.pop();
            return moved;
        }

        checkGameOver() {
            for (let r = 0; r < this.size; r++) {
                for (let c = 0; c < this.size; c++) {
                    if (this.grid[r][c] === 0) return false;
                    if (c < this.size - 1 && this.grid[r][c] === this.grid[r][c+1]) return false;
                    if (r < this.size - 1 && this.grid[r][c] === this.grid[r+1][c]) return false;
                }
            }
            return true;
        }
    }

    const game = new Game2048();

</script>
</body>
</html>